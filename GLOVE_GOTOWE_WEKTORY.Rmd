Definicja funkcji wczytującej pretrenowane wektory  
```{r}
proc_pretrained_vec <- function(p_vec) {
  vals <- vector(mode = "list", length(p_vec))
  names <- character(length(p_vec))

  for(i in 1:length(p_vec)) {
    if(i %% 10000 == 0) {print(i)}
    this_vec <- p_vec[i]
    this_vec_unlisted <- unlist(strsplit(this_vec, " "))
    this_vec_values <- as.numeric(this_vec_unlisted[-1])
    this_vec_name <- this_vec_unlisted[1]
    vals[[i]] <- this_vec_values
    names[[i]] <- this_vec_name
  }
  
  glove <- data.frame(vals)
  names(glove) <- names

  return(glove)
}
```

Wczytywanie pretrenowanych wektorów
```{r}
g6b <- scan(file = "glove.6B.100d.txt", what="", sep="\n")

glove <- proc_pretrained_vec(g6b)
glove_T = t(glove)
library(text2vec)
```

Sprawdzenie poprawności działania
```{r}
fruit = glove_T["king", , drop = FALSE] - glove_T["man", , drop = FALSE] + glove_T["woman", , drop = FALSE]  
cos_sim = sim2(x = glove_T, y = fruit, method = "cosine", norm = "l2") 
head(sort(cos_sim[,1], decreasing = TRUE), 5)
```

Przygotowanie danych
```{r}
library(stringr)

df <- read.csv(
  file = 'winemag-data-130k-v2.csv',
  sep = ','
)
# Odrzucenie przykładów nie posiadających wartości w kolumnie opisu
df_processed <- df[,colSums(is.na(df["description"]))<nrow(df)]

# Zamiana wszyskich znaków na małe znaki
df_processed[["description"]] <- tolower(df_processed[["description"]])

# Odrzucenie wszystkich znaków specjalnych oraz liczb poza znakiem "'" specyficznym dla języka ang
df_processed[["description"]] <- str_replace(gsub("([^a-z'])", 
                                                  " ", 
                                                  df_processed[["description"]]), 
                                             "B", 
                                             "b") 

# Usunięcie powtórzonych spacji
df_processed[["description"]] <-str_replace(gsub("\\s+",
                                                 " ",
                                                 df_processed[["description"]]),
                                              "B",
                                              "b")

# Usunięcie spacji na końcu opisu
df_processed[["description"]] <-str_replace(gsub("\\s$", "", df_processed[["description"]]), "B", "b")
```

Twożenie Tokenów
```{r}
tokens = word_tokenizer(df_processed$description)
```

Przygotowanie listy słów występujących w recenzjach win
```{r}
tokens_flat <- unlist(tokens, recursive=FALSE)
tokens_flat_uniq <- unique(tokens_flat)
```

Przycinanie glove_T ze względu na słowa występujące w recenzjach win (Zwiekszenie wydajności)
```{r}
glove_T_cut <- glove_T[ row.names(glove_T) %in% tokens_flat_uniq, ]
```

Dopisanie wektorów zerowych do glove_T_cut dla słów występujących w recenzjach win ale niewystępujących w zaczytanych wektorach
```{r}
# Słowa znajdujące się w recenzjach ale nie znajdujace się w glove_T_cut
words_missing_in_glove_T_cut <-tokens_flat_uniq[!(tokens_flat_uniq %in% row.names(glove_T_cut))]

# Utworzenie macierzy zerowej o liczbie kolumn odpowiadającej macierzy glove_T_cut oraz wierszy odpowiedajacej liczbie brakujących słów
words_missing_in_glove_T_cut_matrix <- matrix(0, 
                                              length(words_missing_in_glove_T_cut),
                                              dim(glove_T_cut)[2])

#Dopisanie nazw wierszy z listy brakujących słów
rownames(words_missing_in_glove_T_cut_matrix) <- words_missing_in_glove_T_cut

#Dołączenie do glove_T_cut macierzy zerowej dla brakujących wektorów
glove_T_cut_missing_words_added <- rbind(glove_T_cut,words_missing_in_glove_T_cut_matrix)
```

Sprawdzenie poprawności poprzedniego kroku
```{r}
print("missing words")
length(words_missing_in_glove_T_cut)
print("words in glove")
dim(glove_T_cut)[1]
print("sum")
length(words_missing_in_glove_T_cut)+dim(glove_T_cut)[1]
print("unique words in tokens")
length(tokens_flat_uniq)
print("glove after missing vectors added")
dim(glove_T_cut_missing_words_added)[1]

```

Tworzenie wektorów dla dokumentów 
Dla wszystkich tokenóW pobierane są występujące w nich wektory słów a następnie liczona jest średnia z wartości kolumn (kolumna-współrzędna wektora). Tak powstały wektor wpisywany jest do listy
```{r}
t1 = Sys.time()
doc_vectors_list <- lapply(tokens, function(x) colMeans(glove_T_cut_missing_words_added[x,]))
print(difftime(Sys.time(), t1, units = 'sec'))
```

Przetworzenie listy wektorów do dataframe
```{r}
doc_vectors_df <- data.frame(matrix(unlist(doc_vectors_list), nrow=length(doc_vectors_list), byrow=TRUE))
```

Zapis wyników
```{r}
write.csv(doc_vectors_df,"GLOVE_GOTOWE_WEKTORY.txt", row.names = TRUE)
```